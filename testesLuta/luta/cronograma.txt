1.1 Pegar a função de aparecimendo de imagem da (Área de trabalho -> Tp -> (arqs.c||teste.c) -> main.c)

2. Imagens da face deve ser reimplementadas. Com ajuste segundo o tamanho da tela.

3. Movimentação multipla. AGRUPAR.  
    1. Cima. ok
    2. Baixo. ok
    3. Esquerda. ok 
    4. Direita. ok
    5. Soco. ok
    6. Chute.
    7. Baixo soco. ok
    8. Baixo chute. ok
    9. Cima chute.
    10. Cima soco.
    11. Baixo defende. ok
    12. Alto defende. ok
    13. Normal defende. ok
    14. Especial.
    15. Leva hit.ok
    16. Deitado. ok

4. Achar cenario que se move é e grande.
    1. Mapa um.
    2. Mapa dois.

5. Backgrauds se movem conforme o jogador percorre a tela.


8. Como pausar o jogo(...)

9. Telas.
    0. tela de apertura do jogo com nome, grr, prof, materia, ufpr logo.
    1. Menu.
    2. Seleção de personagem.
    3. Rouds
    4. Telas de ganhador.
    5. Tela de fechamento de jogo AGARDECIMENTO.
     
10. Ajustar telas e detalhes(...)

11. Sonoridade.



13- "Esc" para sair do modo de seleçaõ de personagem.





2. Imagens da face deve ser reimplementadas. Com ajuste segundo o tamanho da tela.

3. Movimentação multipla.
    1. Cima.
    2. Baixo.
    3. Esquerda.
    4. Direita.
    5. Soco.
    6. Chute.
    7. Baixo soco.
    8. Baixo chute.
    9. Cima soco.
    10. Cima chute.
    11. Baixo defende.
    12. Alto defende.
    13. Normal defende.
    14. Especial.
    15. Leva hit baixo.
    16. Leva hit cima.
    17. Deitado.

4. Achar cenario que se move é e grande.
    1. Mapa um.
    2. Mapa dois.

5. Backgrauds se movem conforme o jogador percorre a tela.

6. Implementação da lódgica do hitbox(...)

7. Implementação da lódgica do vida(...)

8. Como pausar o jogo(...)

9. Telas.
    0. tela de apertura do jogo com nome, grr, prof, materia, ufpr logo.
    1. Menu.
    2. Seleção de personagem.
    3. Rouds
    4. Telas de ganhador.
    5. Tela de fechamento de jogo AGARDECIMENTO.
     
10. Ajustar telas e detalhes(...)

11. Sonoridade.
*/






/*
Se o personagem esta abaixado e os dois estão no piso, o personagem que esta abaixado n pode se atingido por glpes do 
hitbox superior, ou seja, pelas ações de soco e chute.
Exemplo digamos que o player 1 esta em pé dando golpes e o player 2 esta abaixado, logo o player 2 n pode receper essas modificações.
Ou seja, n levar dadnno qneuanto esta colidinfo com o personagem, mas somente quando o hit box superiror estiver com dano de ataque,
por que se o bloco que cauda dado dado a anaimação do personagem e eo de ciam e o meu personagem 2 esta enconstando no hit box inferiro 
o memso n eve tomar dano, dado que o hit do dano é o deciam e é ele que esta espandindo,




outr problema que tenho e não sei como resolver é o seguinte, 
o meu hitbox se expande da esquerda para a direita que seria os golpes do personagem 1, mas meu jogador da esquerda esta virado com a face
para o jogador 2, e o 2 coma face para o da esquerda qeu é o jogador 1, mas seus hit boz esta tb da esquerda para a direita,
assim quando realixa a opçaõ de atque seu hitbox aumenta, mas aumenta para o lado errado, ou seja, sodo da direita para a esquerda, mas seu
hitbox aumenta no caso para as costas.



Outar duvida esat fonte que esta sedo usapr apara imprimir a vida e interna do proprio alegrro, ams ele tb n deve ser destruida?




*/





- TEMPO RELOGIO;
- FINALIZAR NA VIDA;
- CONTA ROUND;
- GANHOU DOIS ROUNDS TERMINA; (WHILE).


/*
sim, mas ainda n esta do modo que deve ser:

deve ser assim:



      p1         p2

os dois estão se encarando ou sera p1 olha para p2 e p2 olha para p1
Logo seus hitbox deve se espandir em direções diferentes e não opostas:



      p1->     <-p2


Um confronto um na direçaõ do outro e é claro se os dois se invertera o memo deve ocorrer
com o hitbox:

      p2->     <-p1



*/






/* Tenho certo atrazo ao entar na minha função tela contro os bonecos ficam se movimentando muito rapido ao entrar em tal função, mas após serto tempo
elas se ajustam e entarm um no tempo correto da passagem do tempo .
Não seicomo arrumar isso, dado que recepo o tempo fundo do main e apos o seleção dos personagems;
desta forma, gostaria de arrumar isso, não sei se seria intereçande a criaçaõ de uam novo tempo para a função, ou se podemos arrumar sem esta artificio

*/

/*
Teria como arrumar meu código sem que seja necessário a criação de um novo tempo algo como delta_time que calcula e ajusta este tempo.

*/

/*
o Problema continua n foi resolvido teria como ajustar aocm uam conta o tempo para que ele passe de modo uniforme dentro da função, ou criar um tempo especifico para a mesmo?

*/

/*

Cada jogador deve ter uma variável que conta quantas vezes ele ganhou, assim, quero um sistema de rounds melhor de tres, ou seja,
dado um sistema melhor de 3, ou seja o jogaodr que ganhar dois raund primeiro ganha a partida.

logo o boneco ganha uma raund quando a vida de seu adversario é igual ou menor que zero, desta form o outro boneco ganhou um raund.
Exemlo: p1 ataca p2. A vida de p2 vai para 0 ou menor que isso logo p1 ganhou um raund, assim o maximo de raund é 3.


assim o botão de "esc" n definira mais a volta para o menu e sim a vida dos bonecos, desta forma se a vida de um boneco chegar a 0 ou menor que isso ele deve
incrmentar a variavel vitoria do boneco vitorioso e continuar para um proximo raund, ou se for a dsegunda vitorio de boneco imprimir no terminal qual boneco ganhou.



*/

/*
            // Desenha a vida dos personagens
            //al_draw_textf(al_create_builtin_font(), al_map_rgb(255, 255, 255), 10, 10, 0, "Vida P1: %d", game->player1->vida);
            //al_draw_textf(al_create_builtin_font(), al_map_rgb(255, 255, 255), SCREEN_WIDTH - 120, 10, 0, "Vida P2: %d", game->player2->vida);

            // Desenha hitboxes para depuração

            // al_draw_rectangle(game->player1->hitbox_top.x, game->player1->hitbox_top.y,
            //                   game->player1->hitbox_top.x + game->player1->hitbox_top.width,
            //                   game->player1->hitbox_top.y + game->player1->hitbox_top.height, al_map_rgb(0, 255, 0), 2);
            // al_draw_rectangle(game->player1->hitbox_bottom.x, game->player1->hitbox_bottom.y,
            //                   game->player1->hitbox_bottom.x + game->player1->hitbox_bottom.width,
            //                   game->player1->hitbox_bottom.y + game->player1->hitbox_bottom.height, al_map_rgb(255, 0, 0), 2);
            // al_draw_rectangle(game->player2->hitbox_top.x, game->player2->hitbox_top.y,
            //                   game->player2->hitbox_top.x + game->player2->hitbox_top.width,
            //                   game->player2->hitbox_top.y + game->player2->hitbox_top.height, al_map_rgb(0, 255, 0), 2);
            // al_draw_rectangle(game->player2->hitbox_bottom.x, game->player2->hitbox_bottom.y,
            //                   game->player2->hitbox_bottom.x + game->player2->hitbox_bottom.width,
            //                   game->player2->hitbox_bottom.y + game->player2->hitbox_bottom.height, al_map_rgb(0, 0, 255), 2);



            // Desenha hitboxes para depuração

            al_draw_rectangle(game->player1->hitbox_top.x, game->player1->hitbox_top.y,
                              game->player1->hitbox_top.x + game->player1->hitbox_top.width,
                              game->player1->hitbox_top.y + game->player1->hitbox_top.height, al_map_rgb(0, 255, 0), 2);
            al_draw_rectangle(game->player1->hitbox_bottom.x, game->player1->hitbox_bottom.y,
                              game->player1->hitbox_bottom.x + game->player1->hitbox_bottom.width,
                              game->player1->hitbox_bottom.y + game->player1->hitbox_bottom.height, al_map_rgb(255, 0, 0), 2);
            al_draw_rectangle(game->player2->hitbox_top.x, game->player2->hitbox_top.y,
                              game->player2->hitbox_top.x + game->player2->hitbox_top.width,
                              game->player2->hitbox_top.y + game->player2->hitbox_top.height, al_map_rgb(0, 255, 0), 2);
            al_draw_rectangle(game->player2->hitbox_bottom.x, game->player2->hitbox_bottom.y,
                              game->player2->hitbox_bottom.x + game->player2->hitbox_bottom.width,
                              game->player2->hitbox_bottom.y + game->player2->hitbox_bottom.height, al_map_rgb(0, 0, 255), 2);

*/

/*
Poderia arruamr meu sistema de rounds gostaria que o sistema parace nos seguintes casso quando um dos jogadores ganhou duas partidas, ou quando rounds_num chegar a 3;

*/

/*
Poderia arruamr meu sistema de rounds gostaria que o sistema parace nos seguintes casso quando um dos jogadores ganhou duas partidas, ou quando rounds_num chegar a 3;

*/

/*
Tenho uma coisa a melhorar neste código, bom se o por algum acaso o personagem p1 e p2 os dois se matarem, ou seja os dois com a vidsa menor ou iguala zero
seriaum empate mas este caso n esta descrito acima, deste modo gostaria de tartar tal probabilidade, para qunado isso ocorrer o jogo tratar e ao mostrar a iamgem
de quem ganhou em ves de exibir outra imagem, assim, pegando a região 0x0 ate 900x600 do sprites do personagem 1.
Acredito que este evento deva ser tratado primeiro dadoq ue se os dois estão como a viad baixa de zero os dois, n poderam entarr em if inferiores como
p1 vida baixa ou p2 vida baixa.



*/

/*
ACREDITO QUE ESTAS MUDANÇAS DEVEM SER FEITAS NA FUNÇAÕ TELA CONTROLE E
inicia_rounds.
Tenho uma coisa a melhorar neste código, bom se o por algum acaso o personagem p1 e p2 os dois se matarem, ou seja os dois com a vidsa menor ou iguala zero
seriaum empate mas este caso n esta descrito acima, deste modo gostaria de tartar tal probabilidade, para qunado isso ocorrer o jogo tratar e ao mostrar a iamgem
de quem ganhou em ves de exibir outra imagem, assim, pegando a região 0x0 ate 900x600 do sprites do personagem 1.
Acredito que este evento deva ser tratado primeiro dadoq ue se os dois estão como a viad baixa de zero os dois, n poderam entarr em if inferiores como
p1 vida baixa ou p2 vida baixa.

            // Desenha a vida dos personagens
            // al_draw_textf(al_create_builtin_font(), al_map_rgb(255, 255, 255), 10, 10, 0, "Vida P1: %d", game->player1->vida);
            // al_draw_textf(al_create_builtin_font(), al_map_rgb(255, 255, 255), SCREEN_WIDTH - 120, 10, 0, "Vida P2: %d", game->player2->vida);

*/

// backgraund da luta como inserir uma imagem dentro de minha luta ou seja um fundo para a luta, onde os

/*
Ok, gostaria de um mode de pausar o jogo ao pressionar a tecla "esc", mas n sei como fazer isso, acredito que teria que usar as funções do allegro,
criar uma variavel que indica se esta pausado ou não, assim, ao pressionar a tecla "esc" o tempo é parado. E se o tempo esta paado e pressiona a tecla "esc"
o tempo folta a passar normalmente.

Não teria como fazer assim se a tecla foi pressionada e é esc, entçao o tempo é parado, agora se o tempo esta parada e a tecla esc foi pressionada o é despausado.
Destaforma teria comq ue ter uma flag para saver quando esta parado e quando n está.

*/

/*
    Gostaria que quando eu pressionar a tecla "k" para o personagem 1 e a tecla "5" para o persongem 2 os mesmo lançacem uma bola azul com cerca um raio de 50px.

*/

/*
Tenho o segunte problema gostaria que quando pressionar a tecla H o personagem mudase seu sprite, porem isso ocorrem, mas n da forma que eu gostaria, ou seja,
o sprite diferente é exibido, mas sua largura é diferente dos demais, assim como poderia eu pazer esta imagem ser exibida da dorma correta, dado que a animaçaõ é a numero 9
 e tem cerca de 1000px de largura.

especial.
*/

/*tenho o problema que é o seguinte chat, se o personagem/player 2 esta pulando e se move da esquerda para a direita o personagem/player 1 não consegue fazer o mesmo
ou seja, um player esta pulando e consegue se movimentar enquanto pulo, mas o outro n consegue fazer o mesmo so pular, como possso resolver este erro em meu cóodigo?*/


// ok, mas quero que o dois personagens tenha a movimentação independendte do outro, parece que isso n ocorre e que se um personagem esta pulando e se movimnetando ooutro n ppode fazer o mesmo o que é errado.
// O que quero é um movimento fluido entre as possibilidade se um personagem esta pulando e se movendo enquanto isso ocorre quero que o oureo o mesmo tempo tb possa fazer o mesmo, ou seja, 
// se um pula e se move, ao mesmo tempo o outro tb pode fazer isso, assim os dois personagens devem poder se movimentar da direita para esquerda ou vise versa enauqnto estão pualndo no mesmo tempo.



